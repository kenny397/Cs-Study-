## DTO와 VO

> ~~보통 DTO와 VO를 같은 개념으로 생각한다.~~

### DTO : 레이어 간 데이터를 전달하는 객체(데이터 전달용) 

- 데이터 접근 메서드 외에 기능을 가지지 않음
	
- 로직을 갖고 있지 않는 순수한 데이터 객체이며 (setter 와 getter)

- 데이터의 캡슐화를 통해 유연한 대응이 가능함
	- 데이터 요청수 감소 효과


### VO : 값을 가지는 객체 로직을 포함할 수 있다.(값 표현용) 

- 값자체로 의미를 가지는 객체

- 변하지 않는 값을 가지는 객체
	- 값이 변하지 않음을 보장하며 코드의 안정성과 생산성을 높임

- 값이 같다면 동일한 객체
	- 각 개체를 비교하는데 사용되는 ID가 없음
	- 같은 객체인지 판단하기 위해 각 속성들의 값을 비교함
	- equals()와 hashcode를 오버라이딩해야한다
	- hashcode를먼저 비교한다. 그다음 equals로 비교한 후 같은 객체인지 반환한다.


<br>
<br>

#### DTO와 VO의 공통점: 레이어 간 데이터를 전달 할 때 사용가능하다.


#### DTO와 VO의 차이점
|VO|DTO|
|---|----|
|값이 변하지 않음| 값이 변할 수 있음|
|모든 레이어에서 사용가능| 레이어와 레이어 사이에서 사용|
|VO vo(1) == VO vo2(1)|DTO dto(1)!=DTO dto2(1)|
|특정한 비지니스 로직을 가질 수 있음| 데이터 접근 이외의 기능을 가지지 않음|


DTO를 불변 객체로 사용할 수 있다. 
DTO가 전송하고자 하는 데이터가 전송 과정 중에 변조되지 않음을 보장할 수 있다.

#### Entitiy : 실제 DB의 테이블과 매핑되는 클래스 id로 구분된다. 로직을 포함 할 수 있다.

### Entitiy를 DTO로 사용할 수 없다. 
- VIew에서 표현하는 속성 값들이 요청에 따라 계속 달라질 수 있는데 , 그 때마다 entitiy의 속성값이 변경하면 영속성 모델을 표현한 entitiy의 순수성이 모호해지기 떄문에 controller에서 쓸 DTO와 entitiy클래스는 분리하는게 좋다.