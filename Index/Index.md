## Index
(검색을 위해) 임의의 규칙대로 부여된, 임의의 대상을 가르키는 무언가.

### Index in Database
1. 목적 : RDBMS에서 검색 속도를 높이기 위한 기술

Table의 Column을 색인화 함 (따로 파일로 저장)
-> 색인화 된(B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상

1.  단점
* Index 생성시, .mdb 파일 크기가 증가함
* 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듬.
* 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어짐.
* 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로, 성능에 영향을 미침.

1. 상황 분석
* 사용하면 좋은 경우
	(1) Where 절에서 자주 사용되는 Column

	(2) 외래키가 사용되는 Column

	(3) Join에 자주 사용되는 Column

# Index
(검색을 위해) 임의의 규칙대로 부여된, 임의의 대상을 가르키는 무언가.

### Index in Database
1. 목적 : RDBMS에서 검색 속도를 높이기 위한 기술
Table의 Column을 색인화 함 (따로 파일로 저장)
-> 색인화 된(B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상

1.  단점
	* Index 생성시, .mdb 파일 크기가 증가함
	* 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듬.
	* 인덱스 된 Field에서 Data를 업데이트하거나, Record를 추가 또는 삭제시 성능이 떨어짐.
	* 데이터 변경 작업이 자주 일어나는 경우, Index를 재작성해야 하므로, 성능에 영향을 미침.

1. 상황 분석
* 사용하면 좋은 경우
	1. Where 절에서 자주 사용되는 Column
	2. 외래키가 사용되는 Column
	3. Join에 자주 사용되는 Column

* 사용을 피해야 하는 경우
	1. Data 중복도가 높은 Column
	2. DML이 자주 일어나는 Column






### Clustered vs Non-Clustered

#### Clustered : 군집화 된

데이터를 인덱스로 지정한 컬럼에 맞춰서 정렬
* 테이블 구조에 영향을 미치는 인덱스
* 한 테이블에 하나만 생성 가능

1. 클러스터 키로 검색시 처리성능이 매우빠름
1. 이미 정렬된 Clusered Index 는 insert가 힘들다 select는 쉽다.
	* INSERT
	기존 Block에 여유가 없을 때, 새로운 Data가 입력됨
	-> 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행 (**많은 양의 Redo가 기록**되고, 유발)
1. 추가 저장 공간 필요


#### Non-Clustered
인덱스 키 값에는 해당 데이터에 대한 포인터가 존재
* 인덱스의 구조는 데이터 행과 독립적
* 한 테이블에 여러개 생성 가능
